# ts utility types

## Partial

> 属性转为可选

## Required

> 可选转必填

## Record

```ts
Record<K, T> // 给属性 K 添加类型 T   属性映射


type MyRecord<K extends keyof any, T> = {
    [P in K]: T
}

```

## Pick

```ts
Pick<T, K> // 取出T中 包含K的属性组成新的申明类型

type MyPick<T, K extends keyof T> = {
    [P in K]: T[P]
}
```

## Exclude

```ts
Exclude<T, U> // T 中排除分配给 U的属性， 组成新的申明类型

type MyExclude<T, K> = T extends K ? never : T
```

## Extract

```ts
Extract<T, U> // 从 T中找到U相同的属性 组成新的类型

type MyExtract<T, K> = T extends K ? T : never

```

## Omit

```ts
Omit<T, K> // 取出T中不包含 K的属性 组成新的申明类型

type MyOmit<T, K> = MyPick<T, MyExclude<keyof T, K >>

type Omit2<T, K extends keyof any> = {
    [p in Exclude<keyof T, K>]: T[P]
}

```

## Parameters

```ts

Parameters<T>

Parameters<(s: string) => void>  // [string]

// 返回类型为 T的函数的参数组成的数组
```

## ReturnType

```ts
// 获取函数的返回类型
```

## 获取元组的第一个元素

```ts

type First<T extends any[]> = T extends [infer F, ...infer R] ? F : never

```

## 获取构造函数的参数: ConstructorParameters

```ts

```

## ts compiler 内部实现的类型

### Uppercase 小写转大写

### Lowercase 大写转小写

### Capitalize 字符串首字符转大写

### Uncapitalize 字符串首字符转小写

## ts 自定义高级工具



## 总结

```ts

1. keyof 索引查询

2. T[K] 索引访问 // T[keyof T] 联合类型

3. & 交叉类型 key为never

4. extends 继承

前面参数为范型 联合类型时会有出现分发 (依次便利所有字类型进行条件判断), 如果想阻止分发需要通过 元组包裹!

'x' | 'y' extends 'x' ? '1' : '2'


5. 子类型更加具体 父类型约束宽泛, 父类型是子类型的子集

- 可赋值性 父类型可以赋值给子类型 联合类型

- 协变  [父类型] 可以赋值给 [子类型]

- 逆变  关系逆转

- 双向协变

6. infer '用于 extends条件类型中 让 Ts自己推到类型'


7. keyof any ----> string | number | symbol

8. 同态与非同态

9. infer 实现推导数组的类型
```
