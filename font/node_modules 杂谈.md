# 前端包管理杂谈

> 比较著名的:node_modules hell

***早期的npm 设计的时候, 安装包的依赖是层层嵌套 直到最里面一层, 先不论这些包重用的问题 层层嵌套有个很大的问题 就会导致链路很长 路径名会超级长 , 并且在windows系统里面有致命的问题 文件名有 248字符的限制, 并且依赖的依赖会导致包的体积无限膨胀 像黑洞一样是个无底洞***

---

## 项目中安装依赖

***其实很多时候我们并不关心过程, 比如我只要执行yarn 或 npm i的时候很快就能成功。 当然事实与预期不符合,然后就只看到命令行有个进度条好不容易快好的时候, 然后就卡在某个包那里, 然后仔细一看就是以node-sass为首的一些顽固安装包 , 当然了 如果网络不好, 你也会下载很长时间。***

> 为什么有些包下载的时候很慢很慢

```md
以前端工程中常用的包 node-sass 为例子:
1. npm 源速度过慢
2. binding.node源无法访问或速度慢: Downloading binary from https://github.com/sass/node-sass/releases/download/v5.0.0/darwin-x64-72_binding.node
3. node版本与node-sass版本不兼容, node-sass的版本 对node版本有限制,
4. 提示没有安装python、build失败等: 拉取binding.node失败，node-sass会尝试在本地编译binding.node，过程就需要python 然后就报错 ...
```

> 历史版本的npm

***1. npm3.0 以前***

```md
node_modules
  - pa
    - node_modules
      - pa1
就这样的层级一层一层的就非常恐怖, 而windows 目录最长的长度限制 为248字符
缺点:
- 目录层级过深
- 模块实例无法共享
- 安装速度慢的一批
```

***2. npm3 时代***

```md
层级目录扁平化, 但是对于多版本的处理方式, 还是按照之前的处理方式
node_modules
  - pa
  - pb
缺陷:
- 无法保证版本号完全相同, 我们可以限制安装模块的版本号, 但是无法限制 安装模块的依赖的版本号
- 安装速度还是慢
```

***3. yarn 的出现 解决上述的问题:***

```md
- yarn.lock 文件管理依赖版本
- 引入缓存加并行下载保证安装速度
```

***4. npm5 - npm6***

```md
- 引入了 package-lock.json 
- npm6 加入了缓存 优化了安装速度
ps. 其实到了 npm6 vs yarn 性能方面差别不是很大, 还是更喜欢yarn 更加简洁
```

---

### 关于node_modules

> node_modules 为什么没被设计成全局共享的模块?

- 以golang为例, 标准库 三方包只要大家定好用哪个大版本 项目中只用配置好环境变量 然后引包, 当然如果经常需要变动的自己开发的库 就自己及时维护 然后大家都同步更新, 编译后大家都是一样的
- 为npm包提供了快速更新 npm的天然开放性, 只要你符合很低的标准你就能发包, 就导致npm上的包种类很多, 并且这些包都会有无数个版本，当然你需要知道你想要用的是哪个版本
- 全局前端轮子太多了并且版本也多, 全局共享不太适合。个人觉得项目有自己独立的包管理这样更加适合项目本身的特色

---

> node_modules 最让人吐槽的？

- 每次都需要安装依赖，网速慢时很费时间，每次版本更新了，你需要重新更新依赖
- 导致在本地的项目中 node_modules 体积暴增, 每个项目就算 200M+ * 项目个数

---

### 关于package.json 的配置

> key-value

```json
{
  // 如果是当成 cli工具 就需要配置这个命令 5x是执行命令, path指向你的执行文件
  "bin": {
    "5x": "path"
  },
  "name": "项目名字描述",
  "version": "0.0.1",
  "description": "描述这个包的信息!",
  // 对外暴露的引用的地址 
  "main": "index.js",
  // 书写的类型
  "types": "index.d.ts",
  // 我们对项目工程触发的基础命令 dev start build ...
  "scripts": {},
  // 许可证: 
  "license": "",
  "devDependencies": {},
  "dependencies": {},
  "peerDependencies": {
    "React": "~17.0.0",
  },  
}

// 关于依赖项一般是, 'package_name': 'version'
我们很多配置都可以在 package.json 中去配置, 包括: eslint配置, jest配置, babel配置,husky配置等等的 配置信息 但是这些还是建议丢出去去配置, 要不然搞的package.json 比较乱
```

> 关于 devDependencies/ dependencies/ peerDependencies ？

```md
devDependencies: 开发
dependencies: 正式
peerDependencies: 解决插件与所依赖包的不一致问题

// 常见错误如下 当时开发路由的库的时候就遇到了这个问题
如果项目依赖核心库的包 则忽略该插件的 peerDependency 的依赖
如果项目不依赖核心库的包 则会下载该插件的 peerDependency 依赖
```

> 安装包对应的版本符号/还有路径？

```md
1.1.x         -------   1.1.1 ~ <1.2.0 只能是 1.1.x 注意不能跨版本
~1.1.0        -------   1.1.x 
^1.1.0        -------   1.x.x 
// 网络地址
git+https://isaacs@github.com/npm/cli.git
git://github.com/npm/cli.git#v1.0.27
// 本地地址
file:../fool/bar


```

---

### yarn 和 npm的相关信息

> yarn vs npm vs cnpm vs pnpm vs npx

```js
1. npm 包管理工具在3.0的时候由于有很多缺陷, 多版本, 下载慢无缓存 等等问题

2. 16年的时候 有 Fb，google联合推出 替代品 yarn包管理工具,为了解决npm3存在的问题而诞生

3. cnpm 是为了解决墙的问题, cnpm 的仓库是 npm 仓库的一个拷贝
来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”
```

> yarn.lock, package-lock.json 区别 Lockfile的作用?

```md
Lockfile的作用: 
- 确保每次 install 生成稳定的依赖树 锁定依赖 和 依赖的依赖 的版本
- 提升 install的速度, yarn 和 npm 有提取公共依赖版本, 扁平化依赖的 优化策略, lockfile的存在 节省了计算时间

npm 更新lock的更新策略:
- npm 5.0.x 是只按照 lock文件去下载  [issue 地址](https://github.com/npm/npm/issues/16866)
- 5.1.0 - 5.4.2 npm install 会无视lock文件去下载 新的npm 包  [issue 地址](https://github.com/npm/npm/issues/17979)
- 5.4.2 后 改了 package.json 和lock文件不一样, 会以package中的版本号下载对应的包 并且更新到lock文件 (目前的版本是: 6.14.4 也是一样的)

yarn.lock 更新的策略 和 package-lock.json 5.4.2更新策略 后的是一样的!
```

#### 脑洞

1. 假如本地有一份全局的 node_modules 包含了所有版本所有包的版本 ,前端的任何项目 直接的依赖都能指向到这些包中, 但是问题来了: 包的版本是会往前跑的那就得实时更新，并且你的这个全局的包 电脑能装的下吗

2. 或者 重新规划标准基础依赖包,大家都用这些统一的依赖,至于语义化版本(semver)都干掉，只保留唯一版本号就行，哈哈

3. 你想像中的前端包管理最佳实践是怎么样的？

#### 参考文章

1. [Ryan 对nodejs的10大遗憾](https://medium.com/@imior/10-things-i-regret-about-node-js-ryan-dahl-2ba71ff6b4dc)
2. [npm Docs](https://docs.npmjs.com/cli/v6/configuring-npm/folders)
3. [npm和yarn的lockfile杂谈](https://zhuanlan.zhihu.com/p/260094037)
4. [为什么我从 Npm 到 Yarn 再到 Npm?](https://blog.xgheaven.com/2018/05/03/npm-to-yarn-to-npm/)
