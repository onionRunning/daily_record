## 本文讲解关于rn 的一些优化或使用经验

### 调试工具

> 用过哪些工具

#### 1. debugger-ui or element inspector

```
debugger-ui 直接打印显示比较简单
element inspector: 虚拟机 or 真机可以看一些信息,eg: 帧率...
```

#### 2. react-devtools

```
1. 安装: npm install -g react-devtools (安装过程比较慢)
2. 启动: react-devtools
3. 如果没有connect : adb reverse tcp:8097 tcp:8097
[github 地址](https://github.com/facebook/react-devtools/tree/master/packages/react-devtools)
4. 一般用做样式调整
```

#### 3. Reactotron

```
下载Reactotron客户端地址: 
项目中集成Reactotron
yarn add reactotron-react-native -D
reactnative项目中引用: 

import Reactotron,{overlay, openInEditor, networking} from 'reactotron-react-native'
import { mst } from "reactotron-mst"
import store from "./store/root"

const Reacto = Reactotron
  .configure({
    name: "start ReactNative"
  })
  .use(mst())          // 打印 mobx-state-tree 的action... (这里用的状态机mst)
  .use(networking())   // 打印网络请求 
  .connect()           //  开始connect
  .trackMstNode(store,'store')   
export default Reacto
gobal._logger = Reacto  //  全局挂载

ps. 如果你遇到未connect How to connect to Reactotron from Android Phone?
执行下列操作: adb reverse tcp:9090 tcp:9090

```

####  4. react-native-debugger

---

#### rn 项目规范

> 好的目录结构以及清晰的模块划分会让人更加的理清业务逻辑

- 合理规范你的项目目录

```
- Asserts
- Components
- Pages
- Store
- Server            
- Global
- Native    // 原生调用模块
- Router    // 路由层单独抽离开 并且合理划分你的路由层级

...

1. 目录按照规范设定
2. 我们写的比较多的是 Pages 下的逻辑,我们定义的时候按照模块区划分我们的组件,同理状态机也可以采用同样的处理方式
3. 路由层是整个应用的比较直观的模块,合理划分,合理设置 有助于你更加理解整个项目
```

---

#### 印度app: rn的优化方案

- 方案不一定合理,india的rn app方案有这样处理,仅仅做参考

> ***针对rn app我们之前主要是针对android 平台去比较简单层面的优化***

---

#### 1. 接口优化,上下行流量优化

> 减少非必要接口的重复请求(带宽,与用户体验),对于相应字段可以有需要返回

***1.1 接口整合***

```
有很多配置项接口,之前在接口设计时就分为多个接口,然后触发调用的时候 都要走http请求, 对后端的资源是有一定的损耗。 经过沟通,把一些接口进行了整合, 比如: 有一定共性的接口直接在 gateway 进行整合
```

***1.2 参数整合***

```
- 入参: 前端传入的参数,只传后端需要的参数,不要传额外的东西
- 出参: 后端返回的参数, 他们就有的时候为了偷懒,定义一个表结构 struct, 然后返回响应的时候就直接把很多前端不需要的数据进行了返回,其实很多数据都是不需要的,后续整理的时候 就只返回前端需要的数据
```

***1.3 减少接口访问次数***


```
- 减少接口刷新频率: 比如之前做切换时就调用接口， 有些接口可能是需要当你切换到这个路由下就用调用, 但是有些是不需要的, 可以你首次进入的时候触发调用
- 严格控制人为触发: 只有用户触发了相应的条件后，才允许触发你的接口,当然触发的事件: 要加上防抖/节流 防止出现并发的情况
```

---

#### 2. 启动页优化

> 点击logo图标,首页启动的时长需要减少

```
首页启动时间: 从点击app 开始到整个首页内容初始化完毕所损耗的时间
- 预加载(jsbundle 加载提前)
- 首页接口请求前移 or 减少 
- js分包 (如果体积太大的话)

// 预加载
关于预加载是采用网上的方案提前加载jsbundle 是有一点效果，但是与启动页splash 发生了冲突: splash的图片出现了闪动的情况,具体原因也没找到原因,从体验上考虑就没有进行集成

// 接口
首页的接口有很多: 是否更新 + 配置 + app 信息 + 定价方案 + 用户信息 + order status ...
基本上首页的接口非常的多,并且处理的逻辑也很多 导致app进入到首页并且到页面完全渲染完毕耗时比较长,思考方向:梳理有些接口是否可以不用在首页调用 - 之前进入首页之前搞了个中间过度页然后接口前置处理

// 分包
jsbundle 足够大才需要进行分包处理，之前没搞过这个...

```

---

#### 3. 体积优化

> 减少app包的体积: 资源大小优化

- ***图片格式转换***

```
本地资源图片统一转webp格式
```

- ***虚拟机环境***

```
android: abi 只保留 "x86", "x86_64"
```

- ***合理使用三方库***

```
三方插件有些功能很全，但是我们只是用到了其中的一个小小的功能, js / android / ios 就把整个插件都打进 app里 其实一定程度上造成了体积过大, 我们之前的思路就是比较简单的东西可以自己去实现, 实在是很难实现我们才考虑用插件。

```

ps. 当然还有无用资源删除以及代码混淆...

---

#### 4. 针对无网，弱网 给用户友好提示(弹窗提示 or 展示相应的状态)

```
1. 接口在调用的时候会check网络状态 给出相应的提示(eg: 请检查当前网络状态)
2. 页面组件在render时会check当前网络状态 ,给出相应的展示 页面(不能空白)
```


---

#### 5. 本地缓存

> 内置本地sql,对一些特殊接口内容进行缓存处理: 减少请求提升效率, 无网弱网状态下(还是有些内容可见)

```
1. 有些模块的展示是需要与网络强相关,但是有些模块还有些是可以利用缓存缓存接口信息, 提升用户的体验
2. 有些接口信息缓存后，读取本地比服务端更快 
```

---

#### 6. 流畅度

> 体验方面是否出现掉帧卡顿,这个需要通过工具查看帧率的范围,确定是代码层面还是哪里出现的问题(fix)

```
这个没什么很好的方法只能从代码层面上进行深究了
```

---

#### 7. 单元测试 or 自动化测试 

***单元测试***

```
对于单元测试我们之前的项目有着70%代码的覆盖率,有的项目甚至达到了90%以上,当然有些是为了达到一个指标去完成的,为了完成覆盖率来写测试
但是不可否认的是: 有些特定的函数还是需要单元测试,单元测试还是有很多好处的。
后面单独来一个篇章讲解: 单元测试以及 react-hook 如何去测试
```

***自动化测试***

```
appium / detox 跑流程(ui + 接口流程)
```


---

#### 8. 安全问题

```
- 代码混淆
- sentry 监控
- 接口参数加密: md5,比较重要的信息
- 打点监控(流程上)
```
---

#### 9. CI/CD

```
CI: 持续集成, 跑代码check 跑单元测试 跑自动化测试 跑build
CD: 持续部署, 自动部署上线 or 自动发包
```

---

#### 10. HotUpdateHotFixUnity（热更新）

``` 
android 端集成开源的: code-push-cli 本地部署比较麻烦,diff包比较大 下载过程如果网速较慢: 12s左右能下载3M左右的安装包, 快的话: 4-5s 1M 

[官方推荐 + 氪金](https://pushy.reactnative.cn/pricing.html)

- 如果app稳定后(或起量来后)除非涉及到重大版本更新,一般不会去强更新你的app , 这个时候hotfix 是可以承担，bug修复 或小东西的调整修改, 频繁强制更新会对用户造成一定的干扰
```

---

#### 11. 关于loading or hint 体验优化

1. loading 跳动

```
当触发一个接口请求时是需要有loading 过度, 一般是请求结束时,关闭loading 但是如果你是多个接口一起跑，最好的体验就是共用一个loadng，这样就可以避免出现loading跳动的情况
```

2. 设置最小loading 时间 与 最长loading 时长

```
最小loading: 为了避免闪一下就没有的情况
最长loading: 我们之前设置的时长是7s, 7s后关闭loading 然后弹窗提示超时 
```

3. 更加优化 ---> 骨架屏


---

#### 12. 关于组件库 与 原生库

***组件库: qy-rn-component***
[地址](https://www.npmjs.com/package/qy-rn-component)

```
我觉得这个组件库设计的不好,没有一个base规范,并且api设计过于复杂, 初始设计的时候就过度设计,然后也没有一套自己的ui规范,只想着灵活性,忽略掉了很多东西。但是有一说一还是比自己从头去写要好一点点。
```

***原生库: react-native-qy-library***
[地址](https://www.npmjs.com/package/react-native-qy-library)

```
信贷app 需要抓取用户的一些隐私信息,用于风控或者用户行为分析, 然后这个原生库就是为了这个目的,并且大体达到双端的行为几乎一致
```

---

#### 13. 多环境 + 多渠道 + 多平台打包 + 多行为

```
4个环境(dev/test/preprod/prod) * (2-3) 个渠道(马甲包) * 2个平台(android/ios) + 2行为· 打包/启动 (dev/pkg) ios没有集成打包 

最开始的时候要写一大堆命令对应每个打包命令, 通过打包命令在android 生成静态配置，然后rn端去调用拿到这个配置变量,然后通过这个变量区分环境,渠道; 这种方法ios端又要用其他方式进行集成(虽然当时的app没有发布ios版本) 

后面优化在js代码层面需要区分: 后面就采用shell 去更改一个配置文件(xx.ts) 然后js层都去读取这个配置文件(xx.ts) 打包的时候把所有的变量采用命令行的形式处理
```

#### 14 记录几个事故

***1. 关于强更新失败***

```
强更新: 通过app版本号 然后调用后端接口,判断当前app是否需要更新 如果需要更新, android 端跳转google商店

一不小心强更新出现弹窗的代码注视掉了,导致当时所有的用户都用不了,这一批客户流量全部失效(x) -> 重新推广(费用很高)
```

***2. 上传图片未压缩***

```
- 上传用户资料包括图片银行卡信息...(一般至少有5张图片或更多) 图片压缩(luban)当时在某个虚拟机上出现bug,然后代码被注释, 图片能上传但是没有经过压缩处理 导致 储存地址: 20g -> 80g 一个星期, 正常跑了几个月的才到20+g, 一个星期被干完, 服务储存空间当时被运维监控了 然后就运维在服务端对图片资源进行压缩
```



***3. sql查询导致系统异常***

```
语音验证码查询次数,判断后续逻辑 sql查询短信验证码表 ---> 百万级别查询 + 并发, sql缓慢(2次查询, 先查一遍创建的时候有查一遍,2个触发源头 每个源头可触发 5次) 然后服务被卡死,流程中断
- redis查询
- 查询次数储存本地

前后端需求设计阶段,对具体的实现没有考虑到后续的影响
```

***4. docker 节点储存满了***

```
用户无法上传图片资源,中断了流程, appflyer打点没有重视,打点其实可以监控用户行为,导致1个星期 用户没走完申请流程

如果有完整的流程体系的话,需要监控这些闭环操作
```

> 可以发现，无论是从 代码check阶段 还是 需求设计阶段,又或是 上线后的监控行为 把握好这些环节的流程其实可以避免很多重大问题

```
- 压测
- 环境(测试，生产)一致性
```

---

### 针对hula-qinzi项目中比较直观的体验问题
- 首页/呼啦圈 快速点击，路由会跳转2次
- 有些模块出现ui 掉帧的情况, 特别明显的就是 一些模块路由切换时触发出现卡顿的情况
